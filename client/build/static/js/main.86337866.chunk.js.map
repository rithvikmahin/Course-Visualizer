{"version":3,"sources":["components/Search.tsx","components/Graph.tsx","serviceWorker.ts","index.tsx"],"names":["Search","props","fuse","useState","searchTerm","setSearchTerm","courses","setCourses","fuseList","setFuseList","stateRef","useRef","current","length","options","keys","useEffect","document","getElementById","data","Fuse","type","id","className","placeholder","onChange","event","value","target","query","replace","result","search","onClick","action","Colors","layout","name","spacingFactor","nodeSep","rankSep","rankDir","ranker","Graph","state","container","chosenCourse","Fit","bind","ChooseCourse","axios","get","this","setState","Cytoscape","cytoscape","use","dagre","graph","style","selector","width","height","label","backgroundColor","color","opacity","graphLayout","GenerateGraph","on","node","GenerateGraphParents","RestoreGraph","DisplayNodeInfo","run","resize","minZoom","maxZoom","elements","fit","nodeId","subject","number","course","console","log","isCollection","parentNodes","nodes","predecessors","add","others","not","remove","makeLayout","courseObject","fullCourse","filter","group","req","prereq","source","edges","display","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"kYA2DeA,MAlDf,SAAgBC,GAAa,IAUrBC,EAVoB,EACYC,mBAAS,IADrB,mBACjBC,EADiB,KACLC,EADK,OAEMF,mBAAS,MAFf,mBAEjBG,EAFiB,KAERC,EAFQ,OAGQJ,mBAAS,MAHjB,mBAGjBK,EAHiB,KAGPC,EAHO,KAIlBC,EAAWC,mBAGjBD,EAASE,QAAUJ,GAAYA,EAASK,OAAS,GAC9BT,EAAaI,EAAS,GAAT,aAAiCA,EAAS,GAAT,YAAgC,GAKjG,IAAMM,EAAU,CACdC,KAAM,CAAC,UAAW,WAyBpB,OAVAC,qBAAU,WACoBC,SAASC,eAAe,cACpDX,EAAWN,EAAMkB,MAEbb,IACFJ,EAAO,IAAIkB,IAAKd,EAASQ,OAMzB,6BACI,2BAAOO,KAAK,OAAOC,GAAG,aAAaC,UAAU,aAAaC,YAAY,wBAAwBC,SAxBjF,SAACC,GACpB,IAAIC,EAAQD,EAAME,OAAOD,MAGzB,GAFAtB,EAAcsB,GAEVA,EAAO,CAET,IAAME,EAAQF,EAAMG,QAAQ,MAAO,IAC7BC,EAAkB7B,EAAK8B,OAAOH,GACpCpB,EAAYsB,KAgB8GJ,MAAOvB,IAI7H,yBAAKkB,GAAG,gBAAgBC,UAAU,gBAAgBU,QAAS,kBAAMhC,EAAMiC,OAAOxB,EAASE,WAAWF,EAASE,WC1CjHuB,EAAkC,CACtC,KAAQ,UACR,KAAQ,UACR,KAAQ,WAKJC,EACJ,CACEC,KAAM,QACNC,cAAe,GACfC,QAAS,GACTC,QAAS,IACTC,QAAS,KACTC,OAAQ,gBA4OGC,E,kDAvOb,WAAY1C,GAAkB,IAAD,8BAC3B,cAAMA,IACD2C,MAAQ,CACXC,UAAW,KACX1B,KAAM,KACN2B,aAAc,IAEhB,EAAKC,IAAM,EAAKA,IAAIC,KAAT,gBACX,EAAKC,aAAe,EAAKA,aAAaD,KAAlB,gBARO,E,kMAYRE,IAAMC,IAAI,Y,OAAvBhC,E,OACNiC,KAAKC,SAAS,CAAElC,KAAMA,EAAKA,OACrB0B,EAAY5B,SAASC,eAAe,aAC1CkC,KAAKE,UAAUT,GACfO,KAAKC,SAAS,CAAER,UAAWA,I,sIAOnBA,GAAyB,IAAD,OAChCU,IAAUC,IAAIC,KAEd,IAAIC,EAAQH,IACV,CAAEV,UAAWA,EACXc,MAAO,CACL,CACEC,SAAU,OACVD,MAAO,CACN,cAAe,cACf,YAAa,KACZE,MAAO,GACPC,OAAQ,GACRC,MAAO,WACPC,gBAAiB,QACjBC,MAAO,QACP,cAAe,SACf,cAAe,SACfC,QAAS,KAGb,CACEN,SAAU,OACVD,MAAO,CACLE,MAAO,EACP,yBAA0B,QAC1B,yBAA0B,WAC1B,qBAAsB,QACtB,qBAAsB,WACtB,cAAe,SACfK,QAAS,QAMb5D,EAAU8C,KAAKR,MAAMzB,KAGrBgD,GAFNT,EAAQN,KAAKgB,cAAcV,EAAOpD,IAER8B,OAAOA,GAEjCsB,EAAMW,GAAG,MAAO,QAAQ,SAACC,GACvB,EAAKC,qBAAqBD,EAAMZ,GAAO,MAGzCA,EAAMW,GAAG,OAAO,SAAC3C,GACXA,EAAME,QAAU8B,GAClB,EAAKc,aAAad,MAItBA,EAAMW,GAAG,YAAa,QAAQ,SAACC,GAC7B,EAAKG,gBAAgBH,MAGvBH,EAAYO,MACZhB,EAAMiB,SAGNjB,EAAMkB,QAFc,KAGpBlB,EAAMmB,QAFc,KAGpB,IAAMC,EAAWpB,EAAMoB,WAEvB,OADApB,EAAMqB,IAAID,GACHpB,I,sCAGOY,GACd,IAD2C,EACrCU,EAASV,EAAK1C,OAAON,KACrB2D,EAAUD,EAAOlD,QAAQ,SAAU,IACnCoD,EAASF,EAAOlD,QAAQ,SAAU,IAHG,cAOxBsB,KAAKR,MAAMzB,MAPa,IAO3C,2BAAoC,CAAC,IAA5BgE,EAA2B,QAC9BA,EAAM,SAAeF,GAAWE,EAAM,QAAcD,GACtDE,QAAQC,IAAIF,EAAM,cATqB,iC,2CAqBxBb,EAAoDZ,EAAuB4B,EAAuBhE,GACrH,IAAIiE,EACJ,GAAMD,EAUJhB,EAAOA,EAEPiB,GADAA,EAAc7B,EAAM8B,MAAM,QAAUlE,EAAK,MAAMmE,gBACrBC,IAAIpB,OAZX,CAEnB,IAAIU,GADJV,EAAOA,GACW1C,OAAON,KAIzBiE,GAFAA,EAAc7B,EAAM8B,MAAM,QAAUR,EAAS,MAAMS,gBAEzBC,IAAIpB,EAAK1C,QAQrC,IAAI+D,EAASjC,EAAMoB,WAAWc,IAAIL,GAEb7B,EAAMmC,OAAOF,GAClCjC,EAAMoB,WAAWgB,WAAW1D,GAAQsC,MACpChB,EAAMqB,IAAIrB,EAAMoB,c,mCAGLpB,GACX,IAAMb,EAAYO,KAAKR,MAAMC,UAC7B,GAAIA,EAAW,CACb,IAAMa,EAAQN,KAAKE,UAAUT,GAC7Ba,EAAMoB,WAAWgB,WAAW1D,GAAQsC,MACpChB,EAAMqB,IAAIrB,EAAMoB,e,oCASNpB,EAAuBpD,GAEnC,IAAK,IAAMyF,KAAgBzF,EAAS,CAClC,IAAM6E,EAAS7E,EAAQyF,GACjBC,EAAab,EAAM,QAAcA,EAAM,OAEvCzB,EAAMuC,OAAN,qBAA2BD,EAA3B,OAA2CnF,QAC/C6C,EAAMgC,IAAI,CACRQ,MAAO,QACP/E,KAAM,CACJG,GAAI0E,KAKZ,IAAK,IAAMD,KAAgBzF,EAAS,CAClC,IAAM6E,EAAS7E,EAAQyF,GACjBC,EAAab,EAAM,QAAcA,EAAM,OAE7C,IAAK,IAAMgB,KAAOhB,EAAM,QAAa,CACjC,IAAMlB,EAAQ9B,EAAOgE,GACrB,IAAK,IAAIC,KAAUjB,EAAM,QAAYgB,GACnCC,EAASjB,EAAM,QAAYgB,GAAKC,GAGlC1C,EAAMgC,IAAI,CACRQ,MAAO,QACP/E,KAAM,CACJG,GAAG,GAAD,OAAK8E,EAAL,YAAeJ,GACjBK,OAAQD,EACRxE,OAAQoE,KAIZtC,EAAM4C,MAAN,qBAA0BF,EAA1B,YAAoCJ,EAApC,OAAoDrC,MAAM,aAAcM,IAI9E,OAAOP,I,4BAOP,IAAMb,EAAYO,KAAKR,MAAMC,UAC7B,GAAIA,EAAW,CACb,IAAMa,EAAQN,KAAKE,UAAUT,GACvBiC,EAAWpB,EAAMoB,WACvBpB,EAAMqB,IAAID,M,mCAIDhC,GAAuB,IAAD,OACjCM,KAAKC,SACH,CAAEP,aAAcA,IAChB,WACE,IAAMD,EAAY,EAAKD,MAAMC,UAC7B,GAAIA,EAAW,CACb,IAAMa,EAAQ,EAAKJ,UAAUT,GACvBvB,EAAK,EAAKsB,MAAME,aAChBwB,EAAOZ,EAAMxC,eAAeI,GAClC,EAAKiD,qBAAqBD,EAAMZ,GAAO,EAAMpC,S,+BAMnD,OACE,6BACE,yBAAKqC,MAAO,CAAC4C,QAAS,SACpB,yBAAKhF,UAAU,QAAQD,GAAG,cAC1B,yBAAKC,UAAU,UAIb,kBAAC,EAAD,CAAQJ,KAAMiC,KAAKR,MAAMzB,KAAMe,OAAQkB,KAAKH,sB,GAjOpCuD,aClBAC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEF/F,SAASC,eAAe,SDiIpB,kBAAmB+F,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLpC,QAAQoC,MAAMA,EAAMC,c","file":"static/js/main.86337866.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react'\nimport '../css/style.css'\nimport Fuse from 'fuse.js'\nimport Courses from '../types/json'\n\n/**\n * \n * @param data - The object containing the course data, called from the internal API.\n */\nfunction Search(props: any) {\n    const [searchTerm, setSearchTerm] = useState(\"\");\n    const [courses, setCourses] = useState(null);\n    const [fuseList, setFuseList] = useState(null);\n    const stateRef = useRef();\n    \n    // Sets the state reference to display the list of search results.\n    stateRef.current = fuseList && fuseList.length > 0 && \n                       searchTerm ? fuseList[0]['item']['subject'] + fuseList[0]['item']['number'] : '';\n\n    let fuse: {[key: string]: any};\n\n    // The fuse.js options.\n    const options = {\n      keys: ['subject', 'number']\n    }\n    \n    const handleSearch = (event: React.ChangeEvent<HTMLInputElement>) => {\n      let value = event.target.value;\n      setSearchTerm(value);\n\n      if (value) {\n        // Removes whitespace from the search.\n        const query = value.replace(/\\s/g, '');\n        const result: Courses = fuse.search(query);\n        setFuseList(result);\n      }\n    }\n\n    useEffect(() => {\n      const search: HTMLElement = document.getElementById('search-bar');\n      setCourses(props.data);\n\n      if (courses) {\n        fuse = new Fuse(courses, options);\n      }\n\n    });\n\n    return (\n        <div>\n            <input type='text' id='search-bar' className='search-bar' placeholder='Enter a course number' onChange={handleSearch} value={searchTerm}/>\n            {/**\n             * \n             //@ts-ignore */}\n            <div id='search-result' className='search-result' onClick={() => props.action(stateRef.current)}>{stateRef.current}</div>\n        </div>\n    )\n}\n\nexport default Search;","import React, { Component } from 'react';\nimport cytoscape from 'cytoscape'\nimport CytoscapeComponent from 'cytoscape';\nimport dagre from 'cytoscape-dagre'\nimport axios from 'axios'\nimport '../css/style.css'\nimport Search from './Search'\nimport Course from './Course'\nimport Courses from '../types/json'\n\ntype AppProps = {}\n\nconst Colors: {[key: string]: string} = {\n  'req1': '#7045AF',\n  'req2': '#A7D129',\n  'req3': '#FF6C00'\n}\n\n \n// Assigns a layout and fits the graph to the screen. \nconst layout = \n  {\n    name: 'dagre',\n    spacingFactor: 0.8,\n    nodeSep: 40,\n    rankSep: 300,\n    rankDir: 'TB',\n    ranker: 'longest-path'\n  }\n\nclass Graph extends Component<AppProps, {container: HTMLElement | null, data: Courses, chosenCourse: string}> {\n\n  constructor(props: AppProps) {\n    super(props);\n    this.state = {\n      container: null,\n      data: null,\n      chosenCourse: ''\n    }\n    this.Fit = this.Fit.bind(this);\n    this.ChooseCourse = this.ChooseCourse.bind(this);\n  }\n\n  async componentDidMount() {\n    const data = await axios.get('/courses');\n    this.setState({ data: data.data });\n    const container = document.getElementById('cytoscape');\n    this.Cytoscape(container as HTMLElement);\n    this.setState({ container: container });\n  }\n\n  /**\n   * @param container - The div DOM element containing the graph.\n   * @param courses - The JSON list of courses.\n   */\n  Cytoscape(container: HTMLElement) {\n    cytoscape.use(dagre);\n    /** Defines graph properties. */\n    let graph = cytoscape(\n      { container: container,\n        style: [\n          {\n            selector: 'node',\n            style: {\n             'font-family': 'Bahnschrift',\n             'font-size': '18',\n              width: 80,\n              height: 80,\n              label: 'data(id)',\n              backgroundColor: 'white',\n              color: 'black',\n              'text-valign': 'center',\n              'text-halign': 'center',\n              opacity: 0.8\n            }\n          },\n          {\n            selector: 'edge',\n            style: {\n              width: 8, \n              'mid-target-arrow-color': 'white',\n              'mid-target-arrow-shape': 'triangle',\n              'target-arrow-color': 'white',\n              'target-arrow-shape': 'triangle',\n              'curve-style': 'bezier',\n              opacity: 0.8\n            }\n          },\n        ]\n      });\n\n    const courses = this.state.data;\n    graph = this.GenerateGraph(graph, courses);\n\n    const graphLayout = graph.layout(layout);\n\n    graph.on('tap', 'node', (node) => {\n      this.GenerateGraphParents(node, graph, false);\n    });\n\n    graph.on('tap', (event) => {\n      if (event.target == graph) {\n        this.RestoreGraph(graph);\n      }\n    });\n\n    graph.on('mouseover', 'node', (node) => {\n      this.DisplayNodeInfo(node);\n    });\n\n    graphLayout.run();\n    graph.resize();\n    const minimumZoom = 0.35;\n    const maximumZoom = 1.2;\n    graph.minZoom(minimumZoom);\n    graph.maxZoom(maximumZoom);\n    const elements = graph.elements();\n    graph.fit(elements);\n    return graph;\n  }\n\n  DisplayNodeInfo(node: cytoscape.EventObject) {\n    const nodeId = node.target.id();\n    const subject = nodeId.replace(/[0-9]/g, '');\n    const number = nodeId.replace(/[A-Z]/g, '');\n    \n\n    //@ts-ignore\n    for (var course of this.state.data) {\n      if (course['subject'] == subject && course['number'] == number) {\n        console.log(course['description'])\n      }\n    }\n  }\n\n  /**\n   * \n   * @param node - The selected node from either the graph or the search bar.\n   * @param graph - The cytoscape graph object.\n   * @param isCollection - Checks if the selection came from a graph click or a search bar click.\n   * @param id - The id of the node if it came from a search bar click.\n   */\n  GenerateGraphParents(node: cytoscape.EventObject | cytoscape.Collection, graph: cytoscape.Core, isCollection: boolean, id?: string) {\n    let parentNodes;\n    if (!(isCollection)) {\n      node = node as cytoscape.EventObject;\n      let nodeId = node.target.id();\n      // Add all predecessors (nodes and edges) to a collection.\n      parentNodes = graph.nodes('[id=\"' + nodeId + '\"]').predecessors();  \n      // Add the selected node to a collection.\n      parentNodes = parentNodes.add(node.target); \n      // Add all other nodes to the other collection.\n    } else {\n      // Similar to above.\n      node = node as cytoscape.Collection;\n      parentNodes = graph.nodes('[id=\"' + id + '\"]').predecessors();   \n      parentNodes = parentNodes.add(node); \n    }\n    let others = graph.elements().not(parentNodes);  \n    //graph.remove() returns the deleted nodes and edges, so that you can just do cy.add() afterwards\n    const removedNodes = graph.remove(others);  \n    graph.elements().makeLayout(layout).run(); \n    graph.fit(graph.elements());\n  }\n\n  RestoreGraph(graph: cytoscape.Core) {\n    const container = this.state.container;\n    if (container) {\n      const graph = this.Cytoscape(container as HTMLElement);\n      graph.elements().makeLayout(layout).run(); \n      graph.fit(graph.elements());\n    }\n  }\n  /**\n   * \n   * @param graph - An empty cytoscape graph with preconfigured settings.\n   * @param courses - The JSON list of courses.\n   * @return - The cytoscape graph with its nodes and edges added.\n   */\n  GenerateGraph(graph: cytoscape.Core, courses: { [key: string]: any }): cytoscape.Core {\n    /** Adds the current course as a node if it does not exist in the graph. */\n    for (const courseObject in courses) {\n      const course = courses[courseObject];\n      const fullCourse = course['subject'] + course['number'];\n\n      if (!(graph.filter(`node[id = '${fullCourse}']`).length)) {\n        graph.add({\n          group: 'nodes',\n          data: {\n            id: fullCourse\n          }\n        }); \n      }\n    }\n    for (const courseObject in courses) {\n      const course = courses[courseObject];\n      const fullCourse = course['subject'] + course['number'];\n      \n      for (const req in course['prereqs']) {\n          const color = Colors[req];\n          for (let prereq in course['prereqs'][req]) {\n            prereq = course['prereqs'][req][prereq];\n      \n          // Creates an edge between the requirements and the current course. \n          graph.add({\n            group: 'edges',\n            data: {\n              id: `${prereq}-${fullCourse}`,\n              source: prereq,\n              target: fullCourse\n            }\n          });\n          // Sets the color of the edge based on the category of prereq it is.\n          graph.edges(`edge[id = '${prereq}-${fullCourse}']`).style('line-color', color);\n        }\n      }\n  }\n    return graph;\n  }\n\n  /**\n   * Shift the camera view of the graph back to the center upon a button click.\n   */\n  Fit() {\n    const container = this.state.container;\n    if (container) {\n      const graph = this.Cytoscape(container as HTMLElement);\n      const elements = graph.elements();\n      graph.fit(elements);\n    }\n  }\n\n  ChooseCourse(chosenCourse: string) {\n    this.setState(\n      { chosenCourse: chosenCourse },\n      () => {\n        const container = this.state.container;\n        if (container) {\n          const graph = this.Cytoscape(container as HTMLElement);\n          const id = this.state.chosenCourse;\n          const node = graph.getElementById(id);\n          this.GenerateGraphParents(node, graph, true, id);\n        }  \n      });\n  }\n\n  render() {\n    return(\n      <div>\n        <div style={{display: 'flex'}}>\n          <div className='graph' id='cytoscape' />\n          <div className='search'>\n            {/**\n             * \n             //@ts-ignore */}\n            <Search data={this.state.data} action={this.ChooseCourse}/>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Graph;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Graph from './components/Graph';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Graph />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}